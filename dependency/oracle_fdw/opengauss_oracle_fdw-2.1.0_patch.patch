diff --git Makefile Makefile
index e6f8939..4733419 100644
--- Makefile
+++ Makefile
@@ -6,12 +6,12 @@ DOCS = README.oracle_fdw
 REGRESS = oracle_fdw oracle_gis oracle_import oracle_join
 
 # add include and library paths for both Instant Client and regular Client
-PG_CPPFLAGS = -I$(ORACLE_HOME)/sdk/include -I$(ORACLE_HOME)/oci/include -I$(ORACLE_HOME)/rdbms/public -I/usr/include/oracle/12.2/client -I/usr/include/oracle/12.2/client64 -I/usr/include/oracle/12.1/client -I/usr/include/oracle/12.1/client64 -I/usr/include/oracle/11.2/client -I/usr/include/oracle/11.2/client64 -I/usr/include/oracle/11.1/client -I/usr/include/oracle/11.1/client64 -I/usr/include/oracle/10.2.0.5/client -I/usr/include/oracle/10.2.0.5/client64 -I/usr/include/oracle/10.2.0.4/client -I/usr/include/oracle/10.2.0.4/client64 -I/usr/include/oracle/10.2.0.3/client -I/usr/include/oracle/10.2.0.3/client64
-SHLIB_LINK = -L$(ORACLE_HOME) -L$(ORACLE_HOME)/bin -L$(ORACLE_HOME)/lib -l$(ORACLE_SHLIB) -L/usr/lib/oracle/12.2/client/lib -L/usr/lib/oracle/12.2/client64/lib -L/usr/lib/oracle/12.1/client/lib -L/usr/lib/oracle/12.1/client64/lib -L/usr/lib/oracle/11.2/client/lib -L/usr/lib/oracle/11.2/client64/lib -L/usr/lib/oracle/11.1/client/lib -L/usr/lib/oracle/11.1/client64/lib -L/usr/lib/oracle/10.2.0.5/client/lib -L/usr/lib/oracle/10.2.0.5/client64/lib -L/usr/lib/oracle/10.2.0.4/client/lib -L/usr/lib/oracle/10.2.0.4/client64/lib -L/usr/lib/oracle/10.2.0.3/client/lib -L/usr/lib/oracle/10.2.0.3/client64/lib
+PG_CPPFLAGS = -I$(ORACLE_HOME)/sdk/include -I$(ORACLE_HOME)/oci/include -I$(ORACLE_HOME)/rdbms/public -I/usr/include/oracle/19.3/client -I/usr/include/oracle/19.3/client64 -I/usr/include/oracle/18.5/client -I/usr/include/oracle/18.5/client64 -I/usr/include/oracle/18.3/client -I/usr/include/oracle/18.3/client64 -I/usr/include/oracle/12.2/client -I/usr/include/oracle/12.2/client64 -I/usr/include/oracle/12.1/client -I/usr/include/oracle/12.1/client64 -I/usr/include/oracle/11.2/client -I/usr/include/oracle/11.2/client64 -I/usr/include/oracle/11.1/client -I/usr/include/oracle/11.1/client64 -I/usr/include/oracle/10.2.0.5/client -I/usr/include/oracle/10.2.0.5/client64 -I/usr/include/oracle/10.2.0.4/client -I/usr/include/oracle/10.2.0.4/client64 -I/usr/include/oracle/10.2.0.3/client -I/usr/include/oracle/10.2.0.3/client64
+SHLIB_LINK = -L$(ORACLE_HOME) -L$(ORACLE_HOME)/bin -L$(ORACLE_HOME)/lib -L$(ORACLE_HOME)/lib/amd64 -l$(ORACLE_SHLIB) -L/usr/lib/oracle/19.3/client/lib -L/usr/lib/oracle/19.3/client64/lib -L/usr/lib/oracle/18.5/client/lib -L/usr/lib/oracle/18.5/client64/lib -L/usr/lib/oracle/18.3/client/lib -L/usr/lib/oracle/18.3/client64/lib -L/usr/lib/oracle/12.2/client/lib -L/usr/lib/oracle/12.2/client64/lib -L/usr/lib/oracle/12.1/client/lib -L/usr/lib/oracle/12.1/client64/lib -L/usr/lib/oracle/11.2/client/lib -L/usr/lib/oracle/11.2/client64/lib -L/usr/lib/oracle/11.1/client/lib -L/usr/lib/oracle/11.1/client64/lib -L/usr/lib/oracle/10.2.0.5/client/lib -L/usr/lib/oracle/10.2.0.5/client64/lib -L/usr/lib/oracle/10.2.0.4/client/lib -L/usr/lib/oracle/10.2.0.4/client64/lib -L/usr/lib/oracle/10.2.0.3/client/lib -L/usr/lib/oracle/10.2.0.3/client64/lib
 
 ifdef NO_PGXS
 subdir = contrib/oracle_fdw
-top_builddir = ../..
+top_builddir = ../../../../../
 include $(top_builddir)/src/Makefile.global
 include $(top_srcdir)/contrib/contrib-global.mk
 else
@@ -30,3 +30,6 @@ else
 ORACLE_SHLIB=clntsh
 endif
 endif
+
+exclude_option=-fPIE
+override CPPFLAGS := $(filter-out $(exclude_option),$(CPPFLAGS))
diff --git oracle_fdw.c oracle_fdw.cpp
similarity index 97%
rename from oracle_fdw.c
rename to oracle_fdw.cpp
index 061e65e..98240c7 100644
--- oracle_fdw.c
+++ oracle_fdw.cpp
@@ -44,13 +44,11 @@
 #include "nodes/makefuncs.h"
 #include "nodes/nodeFuncs.h"
 #include "nodes/pg_list.h"
-#include "nodes/relation.h"
 #include "optimizer/cost.h"
 #include "optimizer/pathnode.h"
 #include "optimizer/planmain.h"
 #include "optimizer/restrictinfo.h"
 #include "optimizer/tlist.h"
-#include "optimizer/var.h"
 #include "parser/parse_relation.h"
 #include "parser/parsetree.h"
 #include "port.h"
@@ -71,7 +69,16 @@
 #include "utils/rel.h"
 #include "utils/resowner.h"
 #include "utils/timestamp.h"
-#include "utils/tqual.h"
+#if PG_VERSION_NUM < 120000
+#include "nodes/relation.h"
+#include "optimizer/var.h"
+//#include "utils/tqual.h"
+#else
+#include "nodes/pathnodes.h"
+#include "optimizer/optimizer.h"
+#include "access/heapam.h"
+#endif
+
 #include "utils/snapmgr.h"
 #include "utils/syscache.h"
 #include "utils/timestamp.h"
@@ -86,13 +93,13 @@
 #define WIDTH_THRESHOLD 1024
 #endif  /* WIDTH_THRESHOLD */
 
-#if PG_VERSION_NUM < 90200
+#if 0//PG_VERSION_NUM < 90200
 #define OLD_FDW_API
 #else
 #undef OLD_FDW_API
 #endif  /* PG_VERSION_NUM */
 
-#if PG_VERSION_NUM >= 90300
+#if 1//PG_VERSION_NUM >= 90300
 #define WRITE_API
 #else
 #undef WRITE_API
@@ -123,10 +130,10 @@
 #undef JOIN_API
 #endif  /* PG_VERSION_NUM */
 
-#if PG_VERSION_NUM < 110000
+//#if PG_VERSION_NUM < 110000
 /* backport macro from V11 */
-#define TupleDescAttr(tupdesc, i) ((tupdesc)->attrs[(i)])
-#endif  /* PG_VERSION_NUM */
+//#define TupleDescAttr(tupdesc, i) ((tupdesc)->attrs[(i)])
+//#endif  /* PG_VERSION_NUM */
 
 /* older versions don't have JSONOID */
 #ifndef JSONOID
@@ -138,13 +145,13 @@ PG_MODULE_MAGIC;
 /*
  * "true" if Oracle data have been modified in the current transaction.
  */
-static bool dml_in_transaction = false;
+static THR_LOCAL bool dml_in_transaction = false;
 
 /*
  * PostGIS geometry type, set upon library initialization.
  */
-static Oid GEOMETRYOID = InvalidOid;
-static bool geometry_is_setup = false;
+static THR_LOCAL Oid GEOMETRYOID = InvalidOid;
+static THR_LOCAL bool geometry_is_setup = false;
 
 /*
  * Describes the valid options for objects that use this wrapper.
@@ -204,7 +211,7 @@ static struct OracleFdwOption valid_options[] = {
  * be more than one foreign table modified at the same time.
  */
 
-static regproc *output_funcs;
+static THR_LOCAL regproc *output_funcs;
 #endif  /* WRITE_API */
 
 /*
@@ -260,10 +267,10 @@ struct OracleFdwState {
 /*
  * SQL functions
  */
-extern PGDLLEXPORT Datum oracle_fdw_handler(PG_FUNCTION_ARGS);
-extern PGDLLEXPORT Datum oracle_fdw_validator(PG_FUNCTION_ARGS);
-extern PGDLLEXPORT Datum oracle_close_connections(PG_FUNCTION_ARGS);
-extern PGDLLEXPORT Datum oracle_diag(PG_FUNCTION_ARGS);
+extern "C" PGDLLEXPORT Datum oracle_fdw_handler(PG_FUNCTION_ARGS);
+extern "C" PGDLLEXPORT Datum oracle_fdw_validator(PG_FUNCTION_ARGS);
+extern "C" PGDLLEXPORT Datum oracle_close_connections(PG_FUNCTION_ARGS);
+extern "C" PGDLLEXPORT Datum oracle_diag(PG_FUNCTION_ARGS);
 
 PG_FUNCTION_INFO_V1(oracle_fdw_handler);
 PG_FUNCTION_INFO_V1(oracle_fdw_validator);
@@ -291,7 +298,7 @@ static ForeignScan *oracleGetForeignPlan(PlannerInfo *root, RelOptInfo *foreignr
 , Plan *outer_plan
 #endif  /* PG_VERSION_NUM */
 );
-static bool oracleAnalyzeForeignTable(Relation relation, AcquireSampleRowsFunc *func, BlockNumber *totalpages);
+static bool oracleAnalyzeForeignTable(Relation relation, AcquireSampleRowsFunc *func, BlockNumber *totalpages, void* additionalData, bool estimateTableRowNum);
 #endif  /* OLD_FDW_API */
 static void oracleExplainForeignScan(ForeignScanState *node, ExplainState *es);
 static void oracleBeginForeignScan(ForeignScanState *node, int eflags);
@@ -329,7 +336,7 @@ static struct oraTable *build_join_oratable(struct OracleFdwState *fdwState, str
 #endif  /* JOIN_API */
 static void getColumnData(Oid foreigntableid, struct oraTable *oraTable);
 #ifndef OLD_FDW_API
-static int acquireSampleRowsFunc (Relation relation, int elevel, HeapTuple *rows, int targrows, double *totalrows, double *totaldeadrows);
+static int acquireSampleRowsFunc (Relation relation, int elevel, HeapTuple *rows, int targrows, double *totalrows, double *totaldeadrows, void* additionalData, bool estimateTableRowNum);
 static void appendAsType(StringInfoData *dest, const char *s, Oid type);
 #endif  /* OLD_FDW_API */
 static char *deparseExpr(oracleSession *session, RelOptInfo *foreignrel, Expr *expr, const struct oraTable *oraTable, List **params);
@@ -372,6 +379,11 @@ static char *fold_case(char *name, fold_t foldcase);
 #define ADD_REL_QUALIFIER(buf, varno)   \
 		appendStringInfo((buf), "%s%d.", REL_ALIAS_PREFIX, (varno))
 
+static int oracleGetFdwType()
+{
+	return ORACLE_ORC;
+}
+
 /*
  * Foreign-data wrapper handler function: return a struct with pointers
  * to callback routines.
@@ -380,7 +392,7 @@ PGDLLEXPORT Datum
 oracle_fdw_handler(PG_FUNCTION_ARGS)
 {
 	FdwRoutine *fdwroutine = makeNode(FdwRoutine);
-
+	fdwroutine->AcquireSampleRows = acquireSampleRowsFunc;
 #ifdef OLD_FDW_API
 	fdwroutine->PlanForeignScan = oraclePlanForeignScan;
 #else
@@ -411,6 +423,7 @@ oracle_fdw_handler(PG_FUNCTION_ARGS)
 #ifdef IMPORT_API
 	fdwroutine->ImportForeignSchema = oracleImportForeignSchema;
 #endif  /* IMPORT_API */
+	fdwroutine->GetFdwType = oracleGetFdwType;
 
 	PG_RETURN_POINTER(fdwroutine);
 }
@@ -430,7 +443,7 @@ oracle_fdw_validator(PG_FUNCTION_ARGS)
 	Oid catalog = PG_GETARG_OID(1);
 	ListCell *cell;
 	bool option_given[option_count] = { false };
-	int i;
+	unsigned int i;
 
 	/*
 	 * Check that only options supported by oracle_fdw, and allowed for the
@@ -721,9 +734,6 @@ _PG_init(void)
 				errmsg("PostgreSQL version \"%s\" not supported by oracle_fdw",
 					   GetConfigOptionByName("server_version", NULL)),
 				errhint("You'll have to update PostgreSQL to a later minor release.")));
-
-	/* register an exit hook */
-	on_proc_exit(&exitHook, PointerGetDatum(NULL));
 }
 
 #ifdef OLD_FDW_API
@@ -958,14 +968,14 @@ oracleGetForeignPaths(PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid
 		fdwState->order_clause = orderedquery.data;
 
 	/* add the only path */
-	add_path(baserel,
+	add_path(root, baserel,
 		(Path *)create_foreignscan_path(
 					root,
 					baserel,
 #if PG_VERSION_NUM >= 90600
 					NULL,  /* default pathtarget */
-#endif  /* PG_VERSION_NUM */
 					baserel->rows,
+#endif  /* PG_VERSION_NUM */
 					fdwState->startup_cost,
 					fdwState->total_cost,
 					usable_pathkeys,
@@ -1116,7 +1126,7 @@ ForeignScan
 		scan_relid = foreignrel->relid;
 
 		/* check if the foreign scan is for an UPDATE or DELETE */
-		if (foreignrel->relid == root->parse->resultRelation &&
+		if (foreignrel->relid == (unsigned int)root->parse->resultRelation &&
 			(root->parse->commandType == CMD_UPDATE ||
 			root->parse->commandType == CMD_DELETE))
 		{
@@ -1146,7 +1156,7 @@ ForeignScan
 		rel = heap_open(foreigntableid, NoLock);
 
 		/* is there an AFTER trigger FOR EACH ROW? */
-		has_trigger = (foreignrel->relid == root->parse->resultRelation) && rel->trigdesc
+		has_trigger = (foreignrel->relid == (unsigned int)root->parse->resultRelation) && rel->trigdesc
 						&& ((root->parse->commandType == CMD_UPDATE && rel->trigdesc->trig_update_after_row)
 							|| (root->parse->commandType == CMD_DELETE && rel->trigdesc->trig_delete_after_row));
 
@@ -1248,7 +1258,7 @@ ForeignScan
 }
 
 bool
-oracleAnalyzeForeignTable(Relation relation, AcquireSampleRowsFunc *func, BlockNumber *totalpages)
+oracleAnalyzeForeignTable(Relation relation, AcquireSampleRowsFunc *func, BlockNumber *totalpages, void* additionalData, bool estimateTableRowNum)
 {
 	*func = acquireSampleRowsFunc;
 	/* use positive page count as a sign that the table has been ANALYZEd */
@@ -1597,7 +1607,7 @@ oraclePlanForeignModify(PlannerInfo *root, ModifyTable *plan, Index resultRelati
 #endif  /* PG_VERSION_NUM */
 
 	/* check if the foreign table is scanned */
-	if (resultRelation < root->simple_rel_array_size
+	if (resultRelation < (unsigned int)root->simple_rel_array_size
 			&& root->simple_rel_array[resultRelation] != NULL)
 	{
 		/* if yes, copy the foreign table information from the associated RelOptInfo */
@@ -1647,7 +1657,7 @@ oraclePlanForeignModify(PlannerInfo *root, ModifyTable *plan, Index resultRelati
 #if PG_VERSION_NUM >= 90500
 			tmpset = bms_copy(rte->updatedCols);
 #else
-			tmpset = bms_copy(rte->modifiedCols);
+			tmpset = bms_copy(rte->updatedCols);
 #endif  /* PG_VERSION_NUM */
 
 			while ((col = bms_first_member(tmpset)) >= 0)
@@ -2459,7 +2469,7 @@ oracleImportForeignSchema(ImportForeignSchemaStmt *stmt, Oid serverOid)
 struct OracleFdwState
 *getFdwState(Oid foreigntableid, double *sample_percent)
 {
-	struct OracleFdwState *fdwState = palloc0(sizeof(struct OracleFdwState));
+	struct OracleFdwState *fdwState = (struct OracleFdwState*)palloc0(sizeof(struct OracleFdwState));
 	char *pgtablename = get_rel_name(foreigntableid);
 	List *options;
 	ListCell *cell;
@@ -3304,7 +3314,7 @@ build_join_oratable(struct OracleFdwState *fdwState, struct PathTarget *reltarge
  * 		exceeding this is not used by compute_scalar_stats().
  */
 int
-acquireSampleRowsFunc(Relation relation, int elevel, HeapTuple *rows, int targrows, double *totalrows, double *totaldeadrows)
+acquireSampleRowsFunc(Relation relation, int elevel, HeapTuple *rows, int targrows, double *totalrows, double *totaldeadrows, void* additionalData, bool estimateTableRowNum)
 {
 	int collected_rows = 0, i;
 	struct OracleFdwState *fdw_state;
@@ -3776,7 +3786,7 @@ deparseExpr(oracleSession *session, RelOptInfo *foreignrel, Expr *expr, const st
 				|| strcmp(opername, "|/") == 0
 				|| strcmp(opername, "@") == 0)
 			{
-				left = deparseExpr(session, foreignrel, linitial(oper->args), oraTable, params);
+				left = deparseExpr(session, foreignrel, (Expr*)linitial(oper->args), oraTable, params);
 				if (left == NULL)
 				{
 					pfree(opername);
@@ -3786,7 +3796,7 @@ deparseExpr(oracleSession *session, RelOptInfo *foreignrel, Expr *expr, const st
 				if (oprkind == 'b')
 				{
 					/* binary operator */
-					right = deparseExpr(session, foreignrel, lsecond(oper->args), oraTable, params);
+					right = deparseExpr(session, foreignrel, (Expr*)lsecond(oper->args), oraTable, params);
 					if (right == NULL)
 					{
 						pfree(left);
@@ -3895,7 +3905,7 @@ deparseExpr(oracleSession *session, RelOptInfo *foreignrel, Expr *expr, const st
 			if (! canHandleType(leftargtype))
 				return NULL;
 
-			left = deparseExpr(session, foreignrel, linitial(arrayoper->args), oraTable, params);
+			left = deparseExpr(session, foreignrel, (Expr*)linitial(arrayoper->args), oraTable, params);
 			if (left == NULL)
 				return NULL;
 
@@ -4013,12 +4023,12 @@ deparseExpr(oracleSession *session, RelOptInfo *foreignrel, Expr *expr, const st
 			if (! canHandleType(rightargtype))
 				return NULL;
 
-			left = deparseExpr(session, foreignrel, linitial(((NullIfExpr *)expr)->args), oraTable, params);
+			left = deparseExpr(session, foreignrel, (Expr*)linitial(((NullIfExpr *)expr)->args), oraTable, params);
 			if (left == NULL)
 			{
 				return NULL;
 			}
-			right = deparseExpr(session, foreignrel, lsecond(((NullIfExpr *)expr)->args), oraTable, params);
+			right = deparseExpr(session, foreignrel, (Expr*)lsecond(((NullIfExpr *)expr)->args), oraTable, params);
 			if (right == NULL)
 			{
 				pfree(left);
@@ -4032,7 +4042,7 @@ deparseExpr(oracleSession *session, RelOptInfo *foreignrel, Expr *expr, const st
 		case T_BoolExpr:
 			boolexpr = (BoolExpr *)expr;
 
-			arg = deparseExpr(session, foreignrel, linitial(boolexpr->args), oraTable, params);
+			arg = deparseExpr(session, foreignrel, (Expr*)linitial(boolexpr->args), oraTable, params);
 			if (arg == NULL)
 				return NULL;
 
@@ -4101,7 +4111,7 @@ deparseExpr(oracleSession *session, RelOptInfo *foreignrel, Expr *expr, const st
 				else
 				{
 					/* for CASE arg WHEN ..., use only the right branch of the equality */
-					arg = deparseExpr(session, foreignrel, lsecond(((OpExpr *)whenclause->expr)->args), oraTable, params);
+					arg = deparseExpr(session, foreignrel, (Expr*)lsecond(((OpExpr *)whenclause->expr)->args), oraTable, params);
 				}
 
 				if (arg == NULL)
@@ -4206,7 +4216,7 @@ deparseExpr(oracleSession *session, RelOptInfo *foreignrel, Expr *expr, const st
 
 			/* do nothing for implicit casts */
 			if (func->funcformat == COERCE_IMPLICIT_CAST)
-				return deparseExpr(session, foreignrel, linitial(func->args), oraTable, params);
+				return deparseExpr(session, foreignrel, (Expr*)linitial(func->args), oraTable, params);
 
 			/* get function name and schema */
 			tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(func->funcid));
@@ -4286,7 +4296,7 @@ deparseExpr(oracleSession *session, RelOptInfo *foreignrel, Expr *expr, const st
 				first_arg = true;
 				foreach(cell, func->args)
 				{
-					arg = deparseExpr(session, foreignrel, lfirst(cell), oraTable, params);
+					arg = deparseExpr(session, foreignrel, (Expr*)lfirst(cell), oraTable, params);
 					if (arg == NULL)
 					{
 						pfree(result.data);
@@ -4311,7 +4321,7 @@ deparseExpr(oracleSession *session, RelOptInfo *foreignrel, Expr *expr, const st
 			else if (strcmp(opername, "date_part") == 0)
 			{
 				/* special case: EXTRACT */
-				left = deparseExpr(session, foreignrel, linitial(func->args), oraTable, params);
+				left = deparseExpr(session, foreignrel, (Expr*)linitial(func->args), oraTable, params);
 				if (left == NULL)
 				{
 					pfree(opername);
@@ -4331,7 +4341,7 @@ deparseExpr(oracleSession *session, RelOptInfo *foreignrel, Expr *expr, const st
 					/* remove final quote */
 					left[strlen(left) - 1] = '\0';
 
-					right = deparseExpr(session, foreignrel, lsecond(func->args), oraTable, params);
+					right = deparseExpr(session, foreignrel, (Expr*)lsecond(func->args), oraTable, params);
 					if (right == NULL)
 					{
 						pfree(opername);
@@ -5137,7 +5147,7 @@ Const
 struct OracleFdwState
 *deserializePlanData(List *list)
 {
-	struct OracleFdwState *state = palloc(sizeof(struct OracleFdwState));
+	struct OracleFdwState *state = (struct OracleFdwState*)palloc(sizeof(struct OracleFdwState));
 	ListCell *cell = list_head(list);
 	int i, len;
 	struct paramDesc *param;
@@ -5155,23 +5165,23 @@ struct OracleFdwState
 	state->order_clause = NULL;
 
 	/* dbserver */
-	state->dbserver = deserializeString(lfirst(cell));
+	state->dbserver = deserializeString((Const*)lfirst(cell));
 	cell = lnext(cell);
 
 	/* user */
-	state->user = deserializeString(lfirst(cell));
+	state->user = deserializeString((Const*)lfirst(cell));
 	cell = lnext(cell);
 
 	/* password */
-	state->password = deserializeString(lfirst(cell));
+	state->password = deserializeString((Const*)lfirst(cell));
 	cell = lnext(cell);
 
 	/* nls_lang */
-	state->nls_lang = deserializeString(lfirst(cell));
+	state->nls_lang = deserializeString((Const*)lfirst(cell));
 	cell = lnext(cell);
 
 	/* query */
-	state->query = deserializeString(lfirst(cell));
+	state->query = deserializeString((Const*)lfirst(cell));
 	cell = lnext(cell);
 
 	/* Oracle prefetch count */
@@ -5180,9 +5190,9 @@ struct OracleFdwState
 
 	/* table data */
 	state->oraTable = (struct oraTable *)palloc(sizeof(struct oraTable));
-	state->oraTable->name = deserializeString(lfirst(cell));
+	state->oraTable->name = deserializeString((Const*)lfirst(cell));
 	cell = lnext(cell);
-	state->oraTable->pgname = deserializeString(lfirst(cell));
+	state->oraTable->pgname = deserializeString((Const*)lfirst(cell));
 	cell = lnext(cell);
 	state->oraTable->ncols = (int)DatumGetInt32(((Const *)lfirst(cell))->constvalue);
 	cell = lnext(cell);
@@ -5194,13 +5204,13 @@ struct OracleFdwState
 	for (i=0; i<state->oraTable->ncols; ++i)
 	{
 		state->oraTable->cols[i] = (struct oraColumn *)palloc(sizeof(struct oraColumn));
-		state->oraTable->cols[i]->name = deserializeString(lfirst(cell));
+		state->oraTable->cols[i]->name = deserializeString((Const*)lfirst(cell));
 		cell = lnext(cell);
 		state->oraTable->cols[i]->oratype = (oraType)DatumGetInt32(((Const *)lfirst(cell))->constvalue);
 		cell = lnext(cell);
 		state->oraTable->cols[i]->scale = (int)DatumGetInt32(((Const *)lfirst(cell))->constvalue);
 		cell = lnext(cell);
-		state->oraTable->cols[i]->pgname = deserializeString(lfirst(cell));
+		state->oraTable->cols[i]->pgname = deserializeString((Const*)lfirst(cell));
 		cell = lnext(cell);
 		state->oraTable->cols[i]->pgattnum = (int)DatumGetInt32(((Const *)lfirst(cell))->constvalue);
 		cell = lnext(cell);
@@ -5212,7 +5222,7 @@ struct OracleFdwState
 		cell = lnext(cell);
 		state->oraTable->cols[i]->pkey = (int)DatumGetInt32(((Const *)lfirst(cell))->constvalue);
 		cell = lnext(cell);
-		state->oraTable->cols[i]->val_size = deserializeLong(lfirst(cell));
+		state->oraTable->cols[i]->val_size = deserializeLong((Const*)lfirst(cell));
 		cell = lnext(cell);
 		/* allocate memory for the result value */
 		state->oraTable->cols[i]->val = (char *)palloc(state->oraTable->cols[i]->val_size + 1);
@@ -5230,14 +5240,14 @@ struct OracleFdwState
 	for (i=0; i<len; ++i)
 	{
 		param = (struct paramDesc *)palloc(sizeof(struct paramDesc));
-		param->name = deserializeString(lfirst(cell));
+		param->name = deserializeString((Const*)lfirst(cell));
 		cell = lnext(cell);
 		param->type = DatumGetObjectId(((Const *)lfirst(cell))->constvalue);
 		cell = lnext(cell);
 		param->bindType = (oraBindType)DatumGetInt32(((Const *)lfirst(cell))->constvalue);
 		cell = lnext(cell);
 		if (param->bindType == BIND_OUTPUT)
-			param->value = (void *)42;  /* something != NULL */
+			param->value = (char *)42;  /* something != NULL */
 		else
 			param->value = NULL;
 		param->node = NULL;
@@ -5307,7 +5317,7 @@ find_em_expr_for_rel(EquivalenceClass *ec, RelOptInfo *rel)
 
 	foreach(lc_em, ec->ec_members)
 	{
-		EquivalenceMember *em = lfirst(lc_em);
+		EquivalenceMember *em = (EquivalenceMember*)lfirst(lc_em);
 
 		if (bms_equal(em->em_relids, rel->relids))
 		{
@@ -5453,7 +5463,7 @@ struct OracleFdwState
 *copyPlanData(struct OracleFdwState *orig)
 {
 	int i;
-	struct OracleFdwState *copy = palloc(sizeof(struct OracleFdwState));
+	struct OracleFdwState *copy = (struct OracleFdwState *)palloc(sizeof(struct OracleFdwState));
 
 	copy->dbserver = pstrdup(orig->dbserver);
 	copy->user = pstrdup(orig->user);
@@ -5507,8 +5517,8 @@ void
 subtransactionCallback(SubXactEvent event, SubTransactionId mySubid, SubTransactionId parentSubid, void *arg)
 {
 	/* rollback to the appropriate savepoint on subtransaction abort */
-	if (event == SUBXACT_EVENT_ABORT_SUB || event == SUBXACT_EVENT_PRE_COMMIT_SUB)
-		oracleEndSubtransaction(arg, GetCurrentTransactionNestLevel(), event == SUBXACT_EVENT_PRE_COMMIT_SUB);
+	if (event == SUBXACT_EVENT_ABORT_SUB || event == SUBXACT_EVENT_COMMIT_SUB)
+		oracleEndSubtransaction(arg, GetCurrentTransactionNestLevel(), event == SUBXACT_EVENT_COMMIT_SUB);
 }
 
 /*
@@ -5521,7 +5531,7 @@ addParam(struct paramDesc **paramList, char *name, Oid pgtype, oraType oratype,
 {
 	struct paramDesc *param;
 
-	param = palloc(sizeof(struct paramDesc));
+	param = (struct paramDesc *)palloc(sizeof(struct paramDesc));
 	param->name = pstrdup(name);
 	param->type = pgtype;
 	switch (oratype)
@@ -5596,7 +5606,7 @@ setModifyParameters(struct paramDesc *paramList, TupleTableSlot *newslot, TupleT
 		else
 		{
 			/* for other parameters extract the datum from newslot */
-			datum = slot_getattr(newslot, oraTable->cols[param->colnum]->pgattnum, &isnull);
+			datum = heap_slot_getattr(newslot, oraTable->cols[param->colnum]->pgattnum, &isnull);
 		}
 
 		switch (param->bindType)
@@ -5732,7 +5742,7 @@ setModifyParameters(struct paramDesc *paramList, TupleTableSlot *newslot, TupleT
 				value_len = VARSIZE(datum) - VARHDRSZ;
 
 				/* the first 4 bytes contain the length */
-				param->value = palloc(value_len + 4);
+				param->value = (char*)palloc(value_len + 4);
 				memcpy(param->value, (const char *)&value_len, 4);
 				memcpy(param->value + 4, VARDATA(datum), value_len);
 				break;
@@ -5768,20 +5778,6 @@ transactionCallback(XactEvent event, void *arg)
 {
 	switch(event)
 	{
-#ifdef WRITE_API
-		case XACT_EVENT_PRE_COMMIT:
-#if PG_VERSION_NUM >= 90500
-		case XACT_EVENT_PARALLEL_PRE_COMMIT:
-#endif  /* PG_VERSION_NUM */
-			/* remote commit */
-			oracleEndTransaction(arg, 1, 0);
-			break;
-		case XACT_EVENT_PRE_PREPARE:
-			ereport(ERROR,
-					(errcode(ERRCODE_FDW_UNABLE_TO_CREATE_EXECUTION),
-					errmsg("cannot prepare a transaction that used remote tables")));
-			break;
-#endif  /* WRITE_API */
 		case XACT_EVENT_COMMIT:
 		case XACT_EVENT_PREPARE:
 #if PG_VERSION_NUM >= 90500
@@ -5801,6 +5797,8 @@ transactionCallback(XactEvent event, void *arg)
 			/* remote rollback */
 			oracleEndTransaction(arg, 0, 1);
 			break;
+		default:
+			break;
 	}
 
 	dml_in_transaction = false;
@@ -6009,14 +6007,14 @@ convertTuple(struct OracleFdwState *fdw_state, Datum *values, bool *nulls, bool
 			ora_geometry *geom = (ora_geometry *)fdw_state->oraTable->cols[index]->val;
 
 			/* install error context callback */
-			errcb.previous = error_context_stack;
-			error_context_stack = &errcb;
+			errcb.previous = t_thrd.log_cxt.error_context_stack;
+			t_thrd.log_cxt.error_context_stack = &errcb;
 			fdw_state->columnindex = index;
 
 			value_len = oracleGetEWKBLen(fdw_state->session, geom);
 
 			/* uninstall error context callback */
-			error_context_stack = errcb.previous;
+			t_thrd.log_cxt.error_context_stack = errcb.previous;
 
 			value = NULL;  /* we will fetch that later to avoid unnecessary copying */
 		}
@@ -6044,8 +6042,8 @@ convertTuple(struct OracleFdwState *fdw_state, Datum *values, bool *nulls, bool
 			struct varlena *result = NULL;
 
 			/* install error context callback */
-			errcb.previous = error_context_stack;
-			error_context_stack = &errcb;
+			errcb.previous = t_thrd.log_cxt.error_context_stack;
+			t_thrd.log_cxt.error_context_stack = &errcb;
 			fdw_state->columnindex = index;
 
 			result = (bytea *)palloc(value_len + VARHDRSZ);
@@ -6053,7 +6051,7 @@ convertTuple(struct OracleFdwState *fdw_state, Datum *values, bool *nulls, bool
 			SET_VARSIZE(result, value_len + VARHDRSZ);
 
 			/* uninstall error context callback */
-			error_context_stack = errcb.previous;
+			t_thrd.log_cxt.error_context_stack = errcb.previous;
 
 			values[j] = PointerGetDatum(result);
 
@@ -6083,7 +6081,7 @@ convertTuple(struct OracleFdwState *fdw_state, Datum *values, bool *nulls, bool
 			if (fdw_state->oraTable->cols[index]->oratype == ORA_TYPE_INTERVALD2S
 				&& value[0] == '-')
 			{
-				char *newval = palloc(strlen(value) + 2);
+				char *newval = (char*)palloc(strlen(value) + 2);
 				char *pos = strchr(value, ' ');
 
 				if (pos == NULL)
@@ -6108,8 +6106,8 @@ convertTuple(struct OracleFdwState *fdw_state, Datum *values, bool *nulls, bool
 			dat = CStringGetDatum(value);
 
 			/* install error context callback */
-			errcb.previous = error_context_stack;
-			error_context_stack = &errcb;
+			errcb.previous = t_thrd.log_cxt.error_context_stack;
+			t_thrd.log_cxt.error_context_stack = &errcb;
 			fdw_state->columnindex = index;
 
 			/* for string types, check that the data are in the database encoding */
@@ -6137,7 +6135,7 @@ convertTuple(struct OracleFdwState *fdw_state, Datum *values, bool *nulls, bool
 			}
 
 			/* uninstall error context callback */
-			error_context_stack = errcb.previous;
+			t_thrd.log_cxt.error_context_stack = errcb.previous;
 		}
 
 		/* free the data buffer for LOBs */
@@ -6206,8 +6204,9 @@ oracleGetShareFileName(const char *relativename)
 
 	get_share_path(my_exec_path, share_path);
 
-	result = palloc(MAXPGPATH);
-	snprintf(result, MAXPGPATH, "%s/%s", share_path, relativename);
+	unsigned int result_len = strlen(share_path) + strlen(relativename) + 2;
+	result = (char*)palloc(result_len);
+	snprintf(result, result_len, "%s/%s", share_path, relativename);
 
 	return result;
 }
@@ -6396,8 +6395,7 @@ void
 initializePostGIS()
 {
 	CatCList *catlist;
-	int i, argcount = 1;
-	Oid argtypes[] = { INTERNALOID };
+	int i;
 
 	/* this needs to be done only once per database session */
 	if (geometry_is_setup)
@@ -6406,10 +6404,9 @@ initializePostGIS()
 	geometry_is_setup = true;
 
 	/* find all functions called "geometry_recv" with "internal" argument type */
-	catlist = SearchSysCacheList2(
+	catlist = SearchSysCacheList1(
 					PROCNAMEARGSNSP,
-					CStringGetDatum("geometry_recv"),
-					PointerGetDatum(buildoidvector(argtypes, argcount)));
+					CStringGetDatum("geometry_recv"));
 
 	for (i = 0; i < catlist->n_members; i++)
 	{
@@ -6436,3 +6433,28 @@ initializePostGIS()
 	}
 	ReleaseSysCacheList(catlist);
 }
+
+struct envEntry* oracleGetConnList(void)
+{
+    return (struct envEntry*)u_sess->ext_fdw_ctx[ORACLE_TYPE_FDW].connList;
+}
+
+void oracleSetConnList(struct envEntry* connList)
+{
+    u_sess->ext_fdw_ctx[ORACLE_TYPE_FDW].connList = connList;
+}
+
+void oracleRegExitProc(void)
+{
+	if (u_sess->ext_fdw_ctx[ORACLE_TYPE_FDW].connList == NULL)
+	{
+		if (IS_THREAD_POOL_SESSION)
+		{
+			u_sess->ext_fdw_ctx[ORACLE_TYPE_FDW].fdwExitFunc = exitHook;
+		}
+		else
+		{
+			on_proc_exit(exitHook, 0);
+		}
+	}
+}
diff --git oracle_fdw.h oracle_fdw.h
index a8f7221..7379b71 100644
--- oracle_fdw.h
+++ oracle_fdw.h
@@ -222,6 +222,9 @@ extern void oracleError_i(oraError sqlstate, const char *message, int arg);
 extern void oracleError(oraError sqlstate, const char *message);
 extern void oracleDebug2(const char *message);
 extern void initializePostGIS(void);
+extern void oracleRegExitProc(void);
+extern struct envEntry* oracleGetConnList(void);
+extern void oracleSetConnList(struct envEntry* connList);
 
 /*
  * functions defined in oracle_gis.c
diff --git oracle_gis.c oracle_gis.cpp
similarity index 99%
rename from oracle_gis.c
rename to oracle_gis.cpp
index 31f9ea1..d97716e 100644
--- oracle_gis.c
+++ oracle_gis.cpp
@@ -81,12 +81,12 @@ typedef struct
 #define mapEntryValid(x) ((x)->from != 0)
 
 /* maps Oracle SRIDs to PostGIS SRIDs */
-static mapEntry *srid_map = NULL;
+static THR_LOCAL mapEntry *srid_map = NULL;
 
 /* contains Oracle error messages, set by checkerr() */
 #define ERRBUFSIZE 500
-static char oraMessage[ERRBUFSIZE];
-static sb4 err_code;
+static THR_LOCAL char oraMessage[ERRBUFSIZE];
+static THR_LOCAL sb4 err_code;
 
 /*
  * Structures needed for managing the MDSYS.SDO_GEOMETRY Oracle type.
@@ -572,7 +572,7 @@ oracleGeometryAlloc(oracleSession *session, ora_geometry *geom)
 				 		session->envp->errhp,
 				 		session->connp->svchp,
 				 		OCI_TYPECODE_OBJECT,
-				 		oracleGetGeometryType(session),
+				 		(OCIType*)oracleGetGeometryType(session),
 				 		(dvoid *)NULL,
 				 		OCI_DURATION_TRANS,
 				 		TRUE,
@@ -1419,8 +1419,8 @@ unpack(oracleSession *session, ora_geometry *geom)
 		oracleError(FDW_ERROR, "error converting SDO_GEOMETRY to geometry: size of SDO_ELEM_INFO must be a multiple of three");
 
 	/* this might be too big if some elements with etype 0 are deleted */
-	geom->elem = oracleAlloc(elemCount * sizeof(unsigned));
-	geom->coord = oracleAlloc(coordCount * sizeof(double));
+	geom->elem = (unsigned int *)oracleAlloc(elemCount * sizeof(unsigned));
+	geom->coord = (double *)oracleAlloc(coordCount * sizeof(double));
 
 	for (elem_i = 0; elem_i + 1 < elemCount; elem_i +=3)
 	{
@@ -1451,7 +1451,7 @@ unpack(oracleSession *session, ora_geometry *geom)
 			elem_pos += 3;
 
 			/* copy ordinates for this entry */
-			for (coord_i=offset - 1; coord_i < next_offset - 1; ++coord_i)
+			for (coord_i=offset - 1; coord_i < (int)(next_offset - 1); ++coord_i)
 				geom->coord[coord_pos++] = coord(session, geom, coord_i);
 		}
 	}
diff --git oracle_utils.c oracle_utils.cpp
similarity index 96%
rename from oracle_utils.c
rename to oracle_utils.cpp
index 71b7c90..5c6da02 100644
--- oracle_utils.c
+++ oracle_utils.cpp
@@ -27,15 +27,15 @@
 #define LOB_CHUNK_SIZE 8132
 
 /* emit no error messages when set, used for shutdown */
-static int silent = 0;
+static THR_LOCAL int silent = 0;
 
 /* contains Oracle error messages, set by checkerr() */
 #define ERRBUFSIZE 500
-static char oraMessage[ERRBUFSIZE];
-static sb4 err_code;
+static THR_LOCAL char oraMessage[ERRBUFSIZE];
+static THR_LOCAL sb4 err_code;
 
 /* set to "1" as soon as OCIEnvCreate is called */
-static int oci_initialized = 0;
+static THR_LOCAL int oci_initialized = 0;
 
 /*
  * Linked list for temporary Oracle handles and descriptors.
@@ -51,15 +51,10 @@ struct handleEntry
 	struct handleEntry *next;
 };
 
-/*
- * Linked list of handles for cached Oracle connections.
- */
-static struct envEntry *envlist = NULL;
-
 /*
  * NULL value used for "in" callback in RETURNING clauses.
  */
-static ora_geometry null_geometry = { NULL, NULL, -1, NULL, -1, NULL };
+static THR_LOCAL ora_geometry null_geometry = { NULL, NULL, -1, NULL, -1, NULL };
 
 /*
  * Helper functions
@@ -119,8 +114,10 @@ oracleSession
 	 */
 	initializePostGIS();
 
+	oracleRegExitProc();
+
 	/* search environment and server handle in cache */
-	for (envp = envlist; envp != NULL; envp = envp->next)
+	for (envp = oracleGetConnList(); envp != NULL; envp = envp->next)
 	{
 		if (strcmp(envp->nls_lang, nls_lang) == 0)
 		{
@@ -147,7 +144,7 @@ oracleSession
 
 		/* create environment handle */
 		if (checkerr(
-			OCIEnvCreate((OCIEnv **) &envhp, (ub4)OCI_OBJECT,
+			OCIEnvCreate((OCIEnv **) &envhp, (ub4)OCI_THREADED,
 				(dvoid *) 0, (dvoid * (*)(dvoid *,size_t)) 0,
 				(dvoid * (*)(dvoid *, dvoid *, size_t)) 0,
 				(void (*)(dvoid *, dvoid *)) 0, (size_t) 0, (dvoid **) 0),
@@ -183,7 +180,7 @@ oracleSession
 		}
 
 		/* add handles to cache */
-		if ((envp = malloc(sizeof(struct envEntry))) == NULL)
+		if ((envp = (struct envEntry*)malloc(sizeof(struct envEntry))) == NULL)
 		{
 			oracleError_i(FDW_OUT_OF_MEMORY,
 				"error connecting to Oracle: failed to allocate %d bytes of memory",
@@ -194,8 +191,8 @@ oracleSession
 		envp->envhp = envhp;
 		envp->errhp = errhp;
 		envp->srvlist = NULL;
-		envp->next = envlist;
-		envlist = envp;
+		envp->next = oracleGetConnList();
+        oracleSetConnList(envp);
 	}
 
 	/* search connect string in cache */
@@ -275,7 +272,7 @@ oracleSession
 		}
 
 		/* add server handle to cache */
-		if ((srvp = malloc(sizeof(struct srvEntry))) == NULL)
+		if ((srvp = (srvEntry*)malloc(sizeof(struct srvEntry))) == NULL)
 		{
 			oracleError_i(FDW_OUT_OF_MEMORY,
 				"error connecting to Oracle: failed to allocate %d bytes of memory",
@@ -373,8 +370,9 @@ oracleSession
 		sprintf(pid, "%lu", (unsigned long)getpid());
 		pid[29] = '\0';
 
+		char tmpstr[30] = "postgres";
 		if (checkerr(
-			OCIAttrSet(userhp, OCI_HTYPE_SESSION, "postgres", (ub4)8,
+			OCIAttrSet(userhp, OCI_HTYPE_SESSION, tmpstr, (ub4)8,
 				OCI_ATTR_MODULE, errhp),
 			(dvoid *)errhp, OCI_HTYPE_ERROR) != OCI_SUCCESS)
 		{
@@ -444,7 +442,7 @@ oracleSession
 		}
 
 		/* add session handle to cache */
-		if ((connp = malloc(sizeof(struct connEntry))) == NULL)
+		if ((connp = (connEntry*)malloc(sizeof(struct connEntry))) == NULL)
 		{
 			oracleError_i(FDW_OUT_OF_MEMORY,
 				"error connecting to Oracle: failed to allocate %d bytes of memory",
@@ -508,7 +506,7 @@ oracleSession
 	}
 
 	/* palloc a data structure pointing to the cached entries */
-	session = oracleAlloc(sizeof(struct oracleSession));
+	session = (oracleSession*)oracleAlloc(sizeof(struct oracleSession));
 	session->envp = envp;
 	session->srvp = srvp;
 	session->connp = connp;
@@ -543,7 +541,8 @@ oracleCloseStatement(oracleSession *session)
 void
 oracleCloseConnections(void)
 {
-	while (envlist != NULL)
+	struct envEntry* envlist = NULL;
+	while ((envlist = oracleGetConnList()) != NULL)
 	{
 		while (envlist->srvlist != NULL)
 		{
@@ -555,6 +554,7 @@ oracleCloseConnections(void)
 		}
 		removeEnvironment(envlist->envhp);
 	}
+    oracleSetConnList(NULL);
 }
 
 /*
@@ -573,6 +573,9 @@ oracleShutdown(void)
 	/* done with Oracle */
 	if (oci_initialized)
 		(void)OCITerminate(OCI_DEFAULT);
+
+    silent = 0;
+    oci_initialized = 0;
 }
 
 /*
@@ -586,7 +589,7 @@ oracleCancel(void)
 	struct srvEntry *srvp;
 
 	/* send a cancel request for all servers ignoring errors */
-	for (envp = envlist; envp != NULL; envp = envp->next)
+	for (envp = oracleGetConnList(); envp != NULL; envp = envp->next)
 		for (srvp = envp->srvlist; srvp != NULL; srvp = srvp->next)
 			(void)OCIBreak(srvp->srvhp, envp->errhp);
 }
@@ -609,8 +612,7 @@ void oracleEndTransaction(void *arg, int is_commit, int noerror)
 		return;
 
 	/* find the cached handles for the argument */
-	envp = envlist;
-	while (envp)
+	while ((envp = oracleGetConnList()) != NULL)
 	{
 		srvp = envp->srvlist;
 		while (srvp)
@@ -711,8 +713,7 @@ oracleEndSubtransaction(void *arg, int nest_level, int is_commit)
 	}
 
 	/* find the cached handles for the argument */
-	envp = envlist;
-	while (envp)
+	while ((envp = oracleGetConnList()) != NULL)
 	{
 		srvp = envp->srvlist;
 		while (srvp)
@@ -814,7 +815,7 @@ struct oraTable
 		qschema = copyOraText(schema, strlen(schema), 1);
 		length += strlen(qschema) + 1;
 	}
-	tablename = oracleAlloc(length + 1);
+	tablename = (char*)oracleAlloc(length + 1);
 	tablename[0] = '\0';  /* empty */
 	if (schema != NULL)
 	{
@@ -828,7 +829,7 @@ struct oraTable
 
 	/* construct a "SELECT * FROM ..." query to describe columns */
 	length += 14;
-	query = oracleAlloc(length + 1);
+	query = (char*)oracleAlloc(length + 1);
 	strcpy(query, "SELECT * FROM ");
 	strcat(query, tablename);
 
@@ -864,7 +865,7 @@ struct oraTable
 	}
 
 	/* allocate an oraTable struct for the results */
-	reply = oracleAlloc(sizeof(struct oraTable));
+	reply = (oraTable*)oracleAlloc(sizeof(struct oraTable));
 	reply->name = tablename;
 	reply->pgname = pgname;
 	reply->npgcols = 0;
@@ -944,7 +945,7 @@ struct oraTable
 		}
 
 		/* create a zero-terminated copy */
-		type_name = oracleAlloc(typname_size + 1);
+		type_name = (char*)oracleAlloc(typname_size + 1);
 		strncpy(type_name, (char *)typname, typname_size);
 		type_name[typname_size] = '\0';
 
@@ -960,7 +961,7 @@ struct oraTable
 		}
 
 		/* create a zero-terminated copy */
-		type_schema = oracleAlloc(typschema_size + 1);
+		type_schema = (char*)oracleAlloc(typschema_size + 1);
 		strncpy(type_schema, (char *)typschema, typschema_size);
 		type_schema[typschema_size] = '\0';
 
@@ -1191,7 +1192,7 @@ oracleExplain(oracleSession *session, const char *query, int *nrows, char ***pla
 			*plan = (char **)oracleRealloc(*plan, sizeof(char *) * (*nrows));
 
 		/* add entry */
-		(*plan)[(*nrows)-1] = oracleAlloc(strlen(res) + 1);
+		(*plan)[(*nrows)-1] = (char*)oracleAlloc(strlen(res) + 1);
 		strcpy((*plan)[(*nrows)-1], res);
 
 		/* fetch next row */
@@ -1426,7 +1427,7 @@ oracleQueryPlan(oracleSession *session, const char *query, const char *desc_quer
 	 */
 
 	/* get the first part of the SQL query with '%' appended */
-	if ((p = strchr(query + 7, ' ')) == NULL)
+	if ((p = strchr(const_cast<char*>(query + 7), ' ')) == NULL)
 	{
 		oracleError(FDW_ERROR, "oracleQueryPlan internal error: no space found in query");
 	}
@@ -1706,7 +1707,7 @@ oraclePrepareQuery(oracleSession *session, const char *query, const struct oraTa
 
 					/* define the result for the named type */
 					if (checkerr(
-						OCIDefineObject(defnhp, session->envp->errhp, oracleGetGeometryType(session),
+						OCIDefineObject(defnhp, session->envp->errhp, (const OCIType*)oracleGetGeometryType(session),
 							(void **)&geom->geometry, 0, (void **)&geom->indicator, 0),
 							session->envp->errhp, OCI_HTYPE_ERROR) != OCI_SUCCESS)
 					{
@@ -1787,7 +1788,7 @@ oracleExecuteQuery(oracleSession *session, const struct oraTable *oraTable, stru
 		++param_count;
 
 	/* allocate a temporary array of indicators */
-	indicators = oracleAlloc(param_count * sizeof(sb2 *));
+	indicators = (sb2*)oracleAlloc(param_count * sizeof(sb2 *));
 
 	/* bind the parameters */
 	param_count = -1;
@@ -1807,13 +1808,13 @@ oracleExecuteQuery(oracleSession *session, const struct oraTable *oraTable, stru
 			switch (param->bindType) {
 				case BIND_NUMBER:
 					/* allocate a new NUMBER */
-					number = oracleAlloc(sizeof(OCINumber));
+					number = (OCINumber*)oracleAlloc(sizeof(OCINumber));
 
 					/*
 					 * Construct number format.
 					 */
 					value_len = strlen(param->value);
-					num_format = oracleAlloc(value_len + 1);
+					num_format = (char*)oracleAlloc(value_len + 1);
 					/* fill everything with '9' */
 					memset(num_format, '9', value_len);
 					num_format[value_len] = '\0';
@@ -1935,7 +1936,7 @@ oracleExecuteQuery(oracleSession *session, const struct oraTable *oraTable, stru
 
 			if (checkerr(
 				OCIBindObject((OCIBind *)param->bindh, session->envp->errhp,
-					oracleGetGeometryType(session), (void **)&geom->geometry, NULL, (void **)&geom->indicator, NULL),
+					(const OCIType*)oracleGetGeometryType(session), (void **)&geom->geometry, NULL, (void **)&geom->indicator, NULL),
 				(dvoid *)session->envp->errhp, OCI_HTYPE_ERROR) != OCI_SUCCESS)
 			{
 				oracleError_d(FDW_UNABLE_TO_CREATE_EXECUTION,
@@ -2122,9 +2123,9 @@ oracleGetLob(oracleSession *session, void *locptr, oraType type, char **value, l
 	{
 		/* extend result buffer */
 		if (*value_len == 0)
-			*value = oracleAlloc(LOB_CHUNK_SIZE + 1);
+			*value = (char*)oracleAlloc(LOB_CHUNK_SIZE + 1);
 		else
-			*value = oracleRealloc(*value, *value_len + LOB_CHUNK_SIZE + 1);
+			*value = (char*)oracleRealloc(*value, *value_len + LOB_CHUNK_SIZE + 1);
 
 		/*
 		 * The first time round, "amount_* = 0" tells OCILobRead to read the whole LOB.
@@ -2251,7 +2252,7 @@ int oracleGetImportColumn(oracleSession *session, char *schema, char **tabname,
 {
 	/* the static variables will contain data returned to the caller */
 	static char s_tabname[129], s_colname[129];
-	char typename[129] = { '\0' }, typeowner[129] = { '\0' }, isnull[2] = { '\0' };
+	char type_name[129] = { '\0' }, typeowner[129] = { '\0' }, isnull[2] = { '\0' };
 	int count = 0;
 	const char * const schema_query = "SELECT COUNT(*) FROM all_users WHERE username = :nsp";
 	const char * const column_query =
@@ -2419,7 +2420,7 @@ int oracleGetImportColumn(oracleSession *session, char *schema, char **tabname,
 
 		if (checkerr(
 			OCIDefineByPos(session->stmthp, &defnhp_typename, session->envp->errhp, (ub4)3,
-				(dvoid *)typename, (sb4)129,
+				(dvoid *)type_name, (sb4)129,
 				SQLT_STR, (dvoid *)&ind_typename,
 				(ub2 *)&len_typename, NULL, OCI_DEFAULT),
 			(dvoid *)session->envp->errhp, OCI_HTYPE_ERROR) != OCI_SUCCESS)
@@ -2543,48 +2544,48 @@ int oracleGetImportColumn(oracleSession *session, char *schema, char **tabname,
 		*nullable = (isnull[0] == 'Y');
 
 		/* figure out correct data type */
-		if (strncmp(typename, "VARCHAR", 7) == 0)
+		if (strncmp(type_name, "VARCHAR", 7) == 0)
 			*type = ORA_TYPE_VARCHAR2;
-		else if (strcmp(typename, "NUMBER") == 0)
+		else if (strcmp(type_name, "NUMBER") == 0)
 			*type = ORA_TYPE_NUMBER;
-		else if (strcmp(typename, "DATE") == 0)
+		else if (strcmp(type_name, "DATE") == 0)
 			*type = ORA_TYPE_DATE;
-		else if (strcmp(typename, "CHAR") == 0)
+		else if (strcmp(type_name, "CHAR") == 0)
 			*type = ORA_TYPE_CHAR;
-		else if (strncmp(typename, "TIMESTAMP", 9) == 0)
+		else if (strncmp(type_name, "TIMESTAMP", 9) == 0)
 		{
-			if (strlen(typename) < 17)
+			if (strlen(type_name) < 17)
 				*type = ORA_TYPE_TIMESTAMP;
 			else
 				*type = ORA_TYPE_TIMESTAMPTZ;
 		}
-		else if (strcmp(typename, "RAW") == 0)
+		else if (strcmp(type_name, "RAW") == 0)
 			*type = ORA_TYPE_RAW;
-		else if (strcmp(typename, "BLOB") == 0)
+		else if (strcmp(type_name, "BLOB") == 0)
 			*type = ORA_TYPE_BLOB;
-		else if (strcmp(typename, "CLOB") == 0)
+		else if (strcmp(type_name, "CLOB") == 0)
 			*type = ORA_TYPE_CLOB;
-		else if (strcmp(typename, "BFILE") == 0)
+		else if (strcmp(type_name, "BFILE") == 0)
 			*type = ORA_TYPE_BFILE;
-		else if (strcmp(typename, "LONG") == 0)
+		else if (strcmp(type_name, "LONG") == 0)
 			*type = ORA_TYPE_LONG;
-		else if (strcmp(typename, "LONG RAW") == 0)
+		else if (strcmp(type_name, "LONG RAW") == 0)
 			*type = ORA_TYPE_LONGRAW;
-		else if (strcmp(typename, "SDO_GEOMETRY") == 0 && ind_typeowner == OCI_IND_NOTNULL && strcmp(typeowner, "MDSYS") == 0)
+		else if (strcmp(type_name, "SDO_GEOMETRY") == 0 && ind_typeowner == OCI_IND_NOTNULL && strcmp(typeowner, "MDSYS") == 0)
 			*type = ORA_TYPE_GEOMETRY;
-		else if (strcmp(typename, "FLOAT") == 0)
+		else if (strcmp(type_name, "FLOAT") == 0)
 			*type = ORA_TYPE_FLOAT;
-		else if (strncmp(typename, "NVARCHAR", 8) == 0)
+		else if (strncmp(type_name, "NVARCHAR", 8) == 0)
 			*type = ORA_TYPE_NVARCHAR2;
-		else if (strcmp(typename, "NCHAR") == 0)
+		else if (strcmp(type_name, "NCHAR") == 0)
 			*type = ORA_TYPE_NCHAR;
-		else if (strncmp(typename, "INTERVAL DAY", 12) == 0)
+		else if (strncmp(type_name, "INTERVAL DAY", 12) == 0)
 			*type = ORA_TYPE_INTERVALD2S;
-		else if (strncmp(typename, "INTERVAL YEAR", 13) == 0)
+		else if (strncmp(type_name, "INTERVAL YEAR", 13) == 0)
 			*type = ORA_TYPE_INTERVALY2M;
-		else if (strcmp(typename, "BINARY_FLOAT") == 0)
+		else if (strcmp(type_name, "BINARY_FLOAT") == 0)
 			*type = ORA_TYPE_BINARYFLOAT;
-		else if (strcmp(typename, "BINARY_DOUBLE") == 0)
+		else if (strcmp(type_name, "BINARY_DOUBLE") == 0)
 			*type = ORA_TYPE_BINARYDOUBLE;
 		else
 			*type = ORA_TYPE_OTHER;
@@ -2648,7 +2649,7 @@ char
 	/* if "string" is parenthized, return a copy */
 	if (string[0] == '(' && string[size-1] == ')')
 	{
-		result = oracleAlloc(size + 1);
+		result = (char*)oracleAlloc(size + 1);
 		memcpy(result, string, size);
 		result[size] = '\0';
 		return result;
@@ -2663,7 +2664,7 @@ char
 		}
 	}
 
-	result = oracleAlloc(resultsize + 1);
+	result = (char*)oracleAlloc(resultsize + 1);
 	if (quote)
 		result[++j] = '"';
 	for (i=0; i<size; ++i)
@@ -2693,7 +2694,7 @@ closeSession(OCIEnv *envhp, OCIServer *srvhp, OCISession *userhp, int disconnect
 	OCITrans *txnhp = NULL;
 
 	/* search environment handle in cache */
-	for (envp = envlist; envp != NULL; envp = envp->next)
+	for (envp = oracleGetConnList(); envp != NULL; envp = envp->next)
 	{
 		if (envp->envhp == envhp)
 			break;
@@ -2798,7 +2799,7 @@ disconnectServer(OCIEnv *envhp, OCIServer *srvhp)
 	struct srvEntry *srvp, *prevsrvp = NULL;
 
 	/* search environment handle in cache */
-	for (envp = envlist; envp != NULL; envp = envp->next)
+	for (envp = oracleGetConnList(); envp != NULL; envp = envp->next)
 	{
 		if (envp->envhp == envhp)
 			break;
@@ -2863,7 +2864,7 @@ removeEnvironment(OCIEnv *envhp)
 	struct envEntry *envp, *prevenvp = NULL;
 
 	/* search environment handle in cache */
-	for (envp = envlist; envp != NULL; envp = envp->next)
+	for (envp = oracleGetConnList(); envp != NULL; envp = envp->next)
 	{
 		if (envp->envhp == envhp)
 			break;
@@ -2887,7 +2888,7 @@ removeEnvironment(OCIEnv *envhp)
 
 	/* remove environment entry from the linked list */
 	if (prevenvp == NULL)
-		envlist = envp->next;
+        oracleSetConnList(envp->next);
 	else
 		prevenvp->next = envp->next;
 
@@ -2908,7 +2909,7 @@ allocHandle(dvoid **handlepp, ub4 type, int isDescriptor, OCIEnv *envhp, struct
 	sword rc;
 
 	/* create entry for linked list */
-	if ((entry = malloc(sizeof(struct handleEntry))) == NULL)
+	if ((entry = (struct handleEntry *)malloc(sizeof(struct handleEntry))) == NULL)
 	{
 		oracleError_i(FDW_OUT_OF_MEMORY,
 			"error allocating handle: failed to allocate %d bytes of memory",
